{% extends "base.html" %} {% block title %}Dashboard & Chat{% endblock %} {%
block content %}
<style>
  /* Main layout container using Flexbox */
  body,
  html {
    height: 100%;
  }

  .dashboard-container {
    display: flex;
    flex-direction: column;
    height: 100vh;
  }

  .main-content-row {
    display: flex;
    flex-grow: 1;
    overflow: hidden;
  }

  /* Custom styles for collapsible sidebars */
  .sidebar {
    transition: all 0.3s ease;
    flex-shrink: 0;
    overflow-x: hidden;
    background-color: #fff;
    border-right: 1px solid #dee2e6; /* Add borders back for separation */
    border-left: 1px solid #dee2e6;
  }

  #left-sidebar {
    width: 250px;
  }

  #right-sidebar {
    width: 300px;
  }

  .sidebar.collapsed {
    width: 60px !important;
    padding-left: 0.5rem !important;
    padding-right: 0.5rem !important;
  }

  .sidebar.collapsed .sidebar-content {
    display: none;
  }

  /* The header and main chat area */
  #main-chat-area {
    flex-grow: 1;
    padding: 3rem; /* Adjust padding as needed */
    overflow-y: auto;
    transition: all 0.3s ease;
  }

  .sidebar .toggle-btn {
    display: block;
    width: 100%;
    text-align: right;
    border: none;
    background: none;
    font-size: 1.5rem;
    cursor: pointer;
    color: #6c757d;
  }

  #left-sidebar .toggle-btn {
    text-align: right;
  }

  #right-sidebar .toggle-btn {
    text-align: left;
  }

  .justified-text {
    text-align: justify;
  }

  html,
  body,
  .dashboard-container,
  .main-content-row,
  #main-chat-area {
    transition: all 0.3s ease;
  }
</style>

<div class="dashboard-container">
  <nav class="navbar navbar-light bg-white border-bottom px-3 py-3 shadow-sm">
    <span class="navbar-brand mb-0 h1 fw-bold">
      <img
        src="/static/logo.jpg"
        alt="TellMeMore Logo"
        style="height: 30px; margin-right: 10px; vertical-align: middle"
      />
      TellMeMore
    </span>
    <div class="d-flex align-items-center">
      <i
        class="bi bi-arrows-fullscreen me-3 text-secondary"
        id="fullscreen-toggle"
        style="cursor: pointer"
        title="Toggle Full Screen"
      ></i>
      <div class="profile-circle me-2" id="header-profile-circle">U</div>
      <a
        href="#"
        id="header-logout-link"
        class="text-danger fw-semibold text-decoration-none"
        >Logout</a
      >
    </div>
  </nav>

  <div class="main-content-row">
    <div
      id="left-sidebar"
      class="bg-white p-3 d-flex flex-column shadow-sm sidebar"
    >
      <button class="toggle-btn" onclick="toggleSidebar('left')">
        <i class="bi bi-list"></i>
      </button>
      <div class="sidebar-content">
        <button
          id="new-session-button"
          class="btn btn-primary w-100 mb-3 d-flex align-items-center justify-content-center py-2 fw-semibold"
          style="border-radius: 0.5rem"
        >
          <i class="bi bi-chat-left-text me-2"></i> New Session
        </button>

        <h6 class="text-secondary mt-3 mb-2 fw-semibold">Previous 7 Days</h6>
        <ul id="sessions-7-days" class="list-unstyled mb-3"></ul>

        <h6 class="text-secondary mt-3 mb-2 fw-semibold">Previous 30 Days</h6>
        <ul id="sessions-30-days" class="list-unstyled mb-3"></ul>

        <p
          class="text-center text-muted small mt-3 d-none"
          id="loading-sessions-sidebar"
        >
          Loading sessions...
        </p>
        <p
          class="text-center text-muted small mt-3 d-none"
          id="no-sessions-sidebar"
        >
          No sessions yet. Create one!
        </p>
      </div>
    </div>

    <div id="main-chat-area" class="d-flex flex-column flex-grow-1">
      <div
        id="chat-area-container"
        class="card shadow-lg flex-grow-1 d-flex flex-column"
        style="border-radius: 1rem"
      >
        <div
          class="card-header bg-white border-bottom d-flex align-items-center py-3"
          style="border-top-left-radius: 1rem; border-top-right-radius: 1rem"
        >
          <div class="col me-2">
            <select class="form-select" id="model-select-left"></select>
          </div>
          <div class="col">
            <select class="form-select" id="model-select-right"></select>
          </div>
        </div>

        <div
          class="card-body p-3 d-flex flex-grow-1 flex-column flex-md-row gap-3 overflow-hidden"
        >
          <div class="col me-2">
            <div
              class="prompt-box rounded-3 flex-grow-1 d-flex flex-column bg-light"
            >
              <h6
                id="chat-title-left"
                class="card-title text-center py-2 border-bottom text-primary fw-bold"
              >
                Conversation 1
              </h6>
              <div id="chat-history-left" class="p-3 overflow-auto flex-grow-1">
                <p class="text-center text-muted">
                  Start typing your first message to begin a conversation.
                </p>
              </div>
            </div>
          </div>
          <div class="col">
            <div
              class="prompt-box rounded-3 flex-grow-1 d-flex flex-column bg-light"
            >
              <h6
                id="chat-title-right"
                class="card-title text-center py-2 border-bottom text-success fw-bold"
              >
                Conversation 2
              </h6>
              <div
                id="chat-history-right"
                class="p-3 overflow-auto flex-grow-1"
              >
                <p class="text-center text-muted">
                  Start typing your first message to begin a conversation.
                </p>
              </div>
            </div>
          </div>
        </div>

        <div
          class="card-footer bg-white p-3 border-top"
          style="
            border-bottom-left-radius: 1rem;
            border-bottom-right-radius: 1rem;
          "
        >
          <form id="send-prompt-form" class="d-flex gap-3">
            <input
              id="new-prompt-text"
              type="text"
              placeholder="Type your message..."
              class="form-control form-control-lg flex-grow-1"
              required
            />
            <button
              id="send-prompt-button"
              type="submit"
              class="btn btn-primary btn-lg fw-bold"
            >
              <i class="bi bi-send-fill"></i>
            </button>
          </form>
        </div>
      </div>
    </div>

    <div
      id="right-sidebar"
      class="bg-white p-3 d-flex flex-column shadow-sm sidebar d-none d-lg-flex"
    >
      <button class="toggle-btn" onclick="toggleSidebar('right')">
        <i class="bi bi-list"></i>
      </button>
      <div class="sidebar-content">
        <div class="card border-0 p-3 mb-4 rounded-3 bg-white shadow-sm">
          <h6 class="fw-bold mb-3 text-primary">System Prompts</h6>
          <div id="system-prompts-list" class="form-check-group">
            <div class="text-center text-muted py-2">
              <div class="spinner-border spinner-border-sm" role="status">
                <span class="visually-hidden">Loading...</span>
              </div>
              Loading...
            </div>
          </div>
        </div>

        <div class="card border-0 p-3 rounded-3 bg-white shadow-sm">
          <h6 class="fw-bold mb-3 text-primary">Userâ€™s Prompts</h6>
          <div id="user-prompts-list" class="form-check-group">
            <div class="text-center text-muted py-2">
              <div class="spinner-border spinner-border-sm" role="status">
                <span class="visually-hidden">Loading...</span>
              </div>
              Loading...
            </div>
          </div>
          <button
            class="btn btn-primary btn-sm mt-3 fw-semibold"
            style="border-radius: 0.5rem"
          >
            <i class="bi bi-plus me-1"></i> Add +
          </button>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock %} {% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/marked@4.0.10/marked.min.js"></script>
<script>
  // --- Global State ---
  let authToken = localStorage.getItem("jwt_token") || null;
  let currentUser = null; // Stored for display purposes
  let activeChatSessionId = null; // The ID of the currently selected/active session
  let activeChatSessionTitle = ""; // The title of the currently selected/active session
  let isNewSessionActive = false; // Flag to indicate if we're in a new, unsaved session

  // Chat history for each model, to be sent with API calls
  let chatHistoryLeft = [];
  let chatHistoryRight = [];
  let allModels = []; // Stores all models from models.txt initially

  // --- DOM Elements ---
  const headerProfileCircle = document.getElementById("header-profile-circle");
  const headerLogoutLink = document.getElementById("header-logout-link");

  const newSessionButton = document.getElementById("new-session-button");
  const sessions7DaysList = document.getElementById("sessions-7-days");
  const sessions30DaysList = document.getElementById("sessions-30-days");
  const loadingSessionsSidebar = document.getElementById(
    "loading-sessions-sidebar"
  );
  const noSessionsSidebar = document.getElementById("no-sessions-sidebar");

  const chatTitleLeft = document.getElementById("chat-title-left");
  const chatTitleRight = document.getElementById("chat-title-right");
  const chatHistoryLeftEl = document.getElementById("chat-history-left");
  const chatHistoryRightEl = document.getElementById("chat-history-right");
  const newPromptTextInput = document.getElementById("new-prompt-text");
  const sendPromptButton = document.getElementById("send-prompt-button");
  const sendPromptForm = document.getElementById("send-prompt-form");

  const modelSelectLeft = document.getElementById("model-select-left");
  const modelSelectRight = document.getElementById("model-select-right");

  const systemPromptsList = document.getElementById("system-prompts-list");
  const userPromptsList = document.getElementById("user-prompts-list");

  // --- Helper Functions ---

  function escapeHTML(str) {
    const div = document.createElement("div");
    div.appendChild(document.createTextNode(str));
    return div.innerHTML;
  }

  async function fetchLLMAPI(endpoint, options = {}) {
    const token = getToken();
    const headers = {
      "Content-Type": "application/json",
      ...options.headers,
    };
    if (token) {
      headers["Authorization"] = `Bearer ${token}`;
    }

    const fullUrl = `${LLM_API_BASE_URL}${
      endpoint.startsWith("/") ? endpoint : "/" + endpoint
    }`;

    try {
      const response = await fetch(fullUrl, {
        ...options,
        headers: headers,
      });

      if (response.status === 401 || response.status === 403) {
        showMessageBox(
          "Your session has expired or is invalid with the LLM API. Please log in again.",
          "danger"
        );
        clearToken();
        return null;
      }
      return response;
    } catch (error) {
      showMessageBox(
        "Network error connecting to LLM API. Please check your connection and try again.",
        "danger"
      );
      console.error("Network fetch error for LLM URL:", fullUrl, error);
      return null;
    }
  }

  // Helper to append messages to a specific chat history box (DOM)
  function appendMessageToChatBox(chatBoxElement, sender, message, type) {
    const messageDiv = document.createElement("div");
    messageDiv.className = `mb-2 p-2 rounded-3 ${
      sender === "You" ? "ms-auto" : "me-auto"
    }`;
    messageDiv.style.maxWidth = "85%";

    // Use marked.js to parse the markdown message into HTML
    const formattedMessage = marked.parse(message);

    // Use a div for the content to ensure markdown is rendered correctly
    const contentDiv = document.createElement("div");
    contentDiv.innerHTML = formattedMessage;

    // Apply styling to the elements within the markdown output
    const messageContainer = document.createElement("div");
    messageContainer.innerHTML = `<small class="fw-semibold justified-text">${sender}:</small>`;
    messageContainer.appendChild(contentDiv);

    messageDiv.appendChild(messageContainer);
    chatBoxElement.appendChild(messageDiv);
    chatBoxElement.scrollTop = chatBoxElement.scrollHeight; // Scroll to bottom
  }

  // --- Core Frontend Logic ---

  async function fetchCurrentUserProfile() {
    console.log(
      "DEBUG: fetchCurrentUserProfile: Attempting to fetch user profile..."
    );
    try {
      const response = await fetchAPI("/auth/protected");
      if (response && response.ok) {
        currentUser = await response.json();
        headerProfileCircle.textContent = (currentUser.name || "U")
          .charAt(0)
          .toUpperCase();
        console.log(
          "DEBUG: fetchCurrentUserProfile: User profile fetched successfully:",
          currentUser
        );
      } else if (response) {
        console.error(
          "DEBUG: fetchCurrentUserProfile: API responded with non-OK status:",
          response.status,
          await response.text()
        );
        showMessageBox("Failed to load user profile.", "danger");
      } else {
        console.error(
          "DEBUG: fetchCurrentUserProfile: fetchAPI returned null (network error or unhandled redirect)."
        );
      }
    } catch (error) {
      console.error(
        "DEBUG: fetchCurrentUserProfile: Caught network error:",
        error
      );
      showMessageBox("Network error fetching user profile.", "danger");
    }
  }

  async function fetchChatSessionsForSidebar() {
    console.log(
      "DEBUG: fetchChatSessionsForSidebar: Attempting to fetch chat sessions..."
    );
    showLoadingSpinner(loadingSessionsSidebar, true);
    noSessionsSidebar.classList.add("d-none");
    sessions7DaysList.innerHTML = "";
    sessions30DaysList.innerHTML = "";

    try {
      const response = await fetchAPI(
        `/chat_sessions/user/${currentUser.user_id}`
      );
      if (response && response.ok) {
        const sessions = await response.json();
        console.log(
          "DEBUG: fetchChatSessionsForSidebar: Chat sessions fetched successfully:",
          sessions
        );

        const now = new Date();
        const sevenDaysAgo = new Date(now);
        sevenDaysAgo.setDate(now.getDate() - 7);
        const thirtyDaysAgo = new Date(now);
        thirtyDaysAgo.setDate(now.getDate() - 30);

        sessions.sort(
          (a, b) => new Date(b.created_at) - new Date(a.created_at)
        );

        sessions.forEach((session) => {
          const createdAt = new Date(session.created_at);

          const sessionItem = document.createElement("li");
          const sessionLink = document.createElement("a");
          sessionLink.href = "#";
          sessionLink.dataset.chatSessionId = session.session_id;
          sessionLink.dataset.chatSessionTitle = session.title;
          sessionLink.className =
            "list-group-item list-group-item-action py-2 text-body d-flex justify-content-between align-items-center";
          sessionLink.textContent = escapeHTML(session.title);

          if (session.session_id === activeChatSessionId) {
            sessionLink.classList.add("active");
            sessionLink.setAttribute("aria-current", "true");
          }

          sessionLink.onclick = (e) => {
            e.preventDefault();
            navigateToChatSession(session.session_id, session.title);
          };

          sessionItem.appendChild(sessionLink);

          if (createdAt >= sevenDaysAgo) {
            sessions7DaysList.appendChild(sessionItem);
          } else if (createdAt >= thirtyDaysAgo) {
            sessions30DaysList.appendChild(sessionItem);
          }
        });

        if (
          sessions7DaysList.children.length === 0 &&
          sessions30DaysList.children.length === 0
        ) {
          noSessionsSidebar.classList.remove("d-none");
        } else {
          noSessionsSidebar.classList.add("d-none");
        }
      } else if (response) {
        console.error(
          "DEBUG: fetchChatSessionsForSidebar: API responded with non-OK status:",
          response.status,
          await response.text()
        );
        showMessageBox("Failed to fetch chat sessions for sidebar.", "danger");
        noSessionsSidebar.classList.remove("d-none");
        noSessionsSidebar.textContent = "Could not load sessions.";
      } else {
        console.error(
          "DEBUG: fetchChatSessionsForSidebar: fetchAPI returned null (network error or unhandled redirect)."
        );
        showMessageBox(
          "Network error fetching chat sessions for sidebar.",
          "danger"
        );
        noSessionsSidebar.classList.remove("d-none");
        noSessionsSidebar.textContent = "Network error loading sessions.";
      }
    } catch (error) {
      console.error(
        "DEBUG: fetchChatSessionsForSidebar: Caught network error:",
        error
      );
      showMessageBox(
        "Network error fetching chat sessions for sidebar.",
        "danger"
      );
      noSessionsSidebar.classList.remove("d-none");
      noSessionsSidebar.textContent = "Network error loading sessions.";
    } finally {
      showLoadingSpinner(loadingSessionsSidebar, false);
    }
  }

  function initializeChatArea(sessionId, sessionTitle) {
    console.log(
      "DEBUG: initializeChatArea: Initializing chat area. SessionId:",
      sessionId,
      "Title:",
      sessionTitle
    );
    activeChatSessionId = sessionId;
    activeChatSessionTitle = sessionTitle;
    newPromptTextInput.value = "";

    chatHistoryLeftEl.innerHTML = "";
    chatHistoryRightEl.innerHTML = "";
    chatHistoryLeft = [];
    chatHistoryRight = [];

    if (sessionId) {
      isNewSessionActive = false;
      chatHistoryLeftEl.innerHTML = `<p class="text-muted text-center"><span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Loading history...</p>`;
      chatHistoryRightEl.innerHTML = `<p class="text-muted text-center"><span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Loading history...</p>`;
      enableChatInput(true);
      newPromptTextInput.focus();
      fetchAndDisplayChatHistory(sessionId);
    } else {
      isNewSessionActive = true;
      chatHistoryLeftEl.innerHTML = `<p class="text-center text-muted">Start typing your first message to begin a conversation.</p>`;
      chatHistoryRightEl.innerHTML = `<p class="text-center text-muted">Start typing your first message to begin a conversation.</p>`;
      enableChatInput(true);
      newPromptTextInput.focus();
      history.pushState(null, "", "/dashboard");
    }
    updateSidebarActiveSession();
  }

  async function fetchAndDisplayChatHistory(sessionId) {
    console.log(
      "DEBUG: fetchAndDisplayChatHistory: Attempting to fetch full history for session:",
      sessionId
    );
    if (!sessionId) return;
    chatHistoryLeftEl.innerHTML = `<p class="text-center text-muted"><span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Loading history...</p>`;
    chatHistoryRightEl.innerHTML = `<p class="text-center text-muted"><span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Loading history...</p>`;

    try {
      const response = await fetchAPI(`/prompts/session/${sessionId}`);
      if (response && response.ok) {
        const prompts = await response.json();
        console.log(
          "DEBUG: fetchAndDisplayChatHistory: Prompts fetched successfully:",
          prompts
        );

        chatHistoryLeftEl.innerHTML = "";
        chatHistoryRightEl.innerHTML = "";
        chatHistoryLeft = [];
        chatHistoryRight = [];

        if (prompts.length > 0) {
          prompts.forEach((prompt) => {
            const userMessage = { role: "user", content: prompt.prompt_text };
            chatHistoryLeft.push(userMessage);
            chatHistoryRight.push(userMessage);

            const leftResponse = prompt.llm_responses[0] || "No response.";
            const rightResponse = prompt.llm_responses[1] || "No response.";

            chatHistoryLeft.push({ role: "assistant", content: leftResponse });
            chatHistoryRight.push({
              role: "assistant",
              content: rightResponse,
            });

            appendMessageToChatBox(
              chatHistoryLeftEl,
              "You",
              prompt.prompt_text,
              "user"
            );
            appendMessageToChatBox(
              chatHistoryLeftEl,
              chatTitleLeft.textContent.replace(" Conversation", ""),
              leftResponse,
              "assistant"
            );

            appendMessageToChatBox(
              chatHistoryRightEl,
              "You",
              prompt.prompt_text,
              "user"
            );
            appendMessageToChatBox(
              chatHistoryRightEl,
              chatTitleRight.textContent.replace(" Conversation", ""),
              rightResponse,
              "assistant"
            );
          });
        } else {
          chatHistoryLeftEl.innerHTML = `<p class="text-center text-muted">No conversation history for this session. Start typing!</p>`;
          chatHistoryRightEl.innerHTML = `<p class="text-center text-muted">No conversation history for this session. Start typing!</p>`;
        }
      } else if (response) {
        console.error(
          "DEBUG: fetchAndDisplayChatHistory: API responded with non-OK status:",
          response.status,
          await response.text()
        );
        chatHistoryLeftEl.innerHTML = `<p class="text-center text-danger">Failed to load chat history.</p>`;
        chatHistoryRightEl.innerHTML = `<p class="text-center text-danger">Failed to load chat history.</p>`;
        showMessageBox("Failed to load chat history for session.", "danger");
      } else {
        console.error(
          "DEBUG: fetchAndDisplayChatHistory: fetchAPI returned null (network error or unhandled redirect)."
        );
        chatHistoryLeftEl.innerHTML = `<p class="text-center text-danger">Network error loading chat history.</p>`;
        chatHistoryRightEl.innerHTML = `<p class="text-center text-danger">Network error loading chat history.</p>`;
        showMessageBox("Network error loading chat history.", "danger");
      }
    } catch (error) {
      console.error(
        "DEBUG: fetchAndDisplayChatHistory: Caught network error:",
        error
      );
      chatHistoryLeftEl.innerHTML = `<p class="text-center text-danger">Network error loading chat history.</p>`;
      chatHistoryRightEl.innerHTML = `<p class="text-center text-danger">Network error loading chat history.</p>`;
      showMessageBox("Network error loading chat history.", "danger");
    } finally {
      setLoadingChat(false);
    }
  }

  /////
  /**
   * Fetches user prompts dynamically based on a user ID and renders them in the dashboard.
   * @param {string} userId - The ID of the current user.
   */
  async function fetchAndDisplayUserPrompts(userId) {
    const userPromptsList = document.getElementById("user-prompts-list");

    // Check if the HTML element exists first
    if (!userPromptsList) {
      console.error(
        "ERROR: The element with ID 'user-prompts-list' was not found."
      );
      return;
    }

    // Check if the userId is provided
    if (!userId) {
      userPromptsList.innerHTML = `<p class="text-danger text-center p-2">User ID is missing. Cannot load prompts.</p>`;
      return;
    }

    try {
      // Fetch prompts using the provided userId
      const response = await fetchAPI(`/user_prompts/user/${userId}`);

      if (!response.ok) {
        throw new Error(`Failed to fetch user prompts: ${response.statusText}`);
      }

      const userPrompts = await response.json();
      console.log(
        "DEBUG: fetchAndDisplayUserPrompts: User prompts fetched successfully:",
        userPrompts
      );

      // Clear the loading indicator.
      userPromptsList.innerHTML = "";

      if (userPrompts.length === 0) {
        userPromptsList.innerHTML = `<p class="text-muted text-center p-2">No user prompts have been created.</p>`;
        return;
      }

      // Create and add a checkbox for each prompt.
      userPrompts.forEach((prompt) => {
        const formCheckDiv = document.createElement("div");
        formCheckDiv.className = "form-check p-2";

        const checkbox = document.createElement("input");
        checkbox.className = "form-check-input";
        checkbox.type = "checkbox";
        checkbox.id = `user-prompt-${prompt.prompt_id}`;
        checkbox.value = prompt.prompt_id;

        const label = document.createElement("label");
        label.className = "form-check-label";
        label.htmlFor = `user-prompt-${prompt.prompt_id}`;
        label.textContent = prompt.prompt_text;

        formCheckDiv.appendChild(checkbox);
        formCheckDiv.appendChild(label);
        userPromptsList.appendChild(formCheckDiv);
      });
    } catch (error) {
      console.error("Error fetching user prompts:", error);
      userPromptsList.innerHTML = `<p class="text-danger text-center p-2">Error loading prompts. Please try again later.</p>`;
    }
  }

  /////

  /**
   * Fetches system prompts dynamically  and renders them in the dashboard.
   */
  async function fetchAndDisplaySystemPrompts() {
    const systemPromptsList = document.getElementById("system-prompts-list");

    // Check if the HTML element exists first
    if (!systemPromptsList) {
      console.error(
        "ERROR: The element with ID 'user-prompts-list' was not found."
      );
      return;
    }

    try {
      // Fetch prompts using the provided userId
      const response = await fetchAPI(`/system_prompts`);

      if (!response.ok) {
        throw new Error(
          `Failed to fetch system prompts: ${response.statusText}`
        );
      }

      const systemPrompts = await response.json();
      console.log(
        "DEBUG: fetchAndDisplaySystemPrompts: System prompts fetched successfully:",
        systemPrompts
      );

      // Clear the loading indicator.
      systemPromptsList.innerHTML = "";

      if (systemPrompts.length === 0) {
        systemPromptsList.innerHTML = `<p class="text-muted text-center p-2">No system prompts have been created.</p>`;
        return;
      }

      // Create and add a checkbox for each prompt.
      systemPrompts.forEach((prompt) => {
        const formCheckDiv = document.createElement("div");
        formCheckDiv.className = "form-check p-2";

        const checkbox = document.createElement("input");
        checkbox.className = "form-check-input";
        checkbox.type = "checkbox";
        checkbox.id = `system-prompt-${prompt.prompt_id}`;
        checkbox.value = prompt.prompt_id;

        const label = document.createElement("label");
        label.className = "form-check-label";
        label.htmlFor = `system-prompt-${prompt.prompt_id}`;
        label.textContent = prompt.prompt_text;

        formCheckDiv.appendChild(checkbox);
        formCheckDiv.appendChild(label);
        systemPromptsList.appendChild(formCheckDiv);
      });
    } catch (error) {
      console.error("Error fetching user prompts:", error);
      systemPromptsList.innerHTML = `<p class="text-danger text-center p-2">Error loading prompts. Please try again later.</p>`;
    }
  }
  /////
  // This function retrieves the text of all user prompts that are currently checked.
  // It assumes the user prompts are contained within an element with the ID 'user-prompts-container',
  // and that each checkbox has a corresponding label with the prompt text.
  function getCheckedUserPrompts() {
    // Select all checked checkboxes that are descendants of the user prompts container.
    // The selector targets elements with the class 'form-check-input' and the ':checked' pseudo-class.
    const checkedCheckboxes = document.querySelectorAll(
      "#user-prompts-container .form-check-input:checked"
    );

    // Initialize an array to store the text of the checked prompts.
    const checkedPrompts = [];

    // Iterate over each checked checkbox found.
    checkedCheckboxes.forEach((checkbox) => {
      // Find the label element associated with the current checkbox.
      // We use the 'for' attribute of the label, which should match the 'id' of the input.
      const promptLabel = document.querySelector(`label[for="${checkbox.id}"]`);

      // If a corresponding label is found, add its text content to the array.
      if (promptLabel) {
        checkedPrompts.push(promptLabel.textContent.trim());
      }
    });

    // Return the array of checked prompt strings.
    return checkedPrompts;
  }

  ////

  function enableChatInput(enable) {
    newPromptTextInput.disabled = !enable;
    sendPromptButton.disabled = !enable;
    if (enable) {
      newPromptTextInput.focus();
    }
  }

  // Helper function to get the API endpoint for a given model
  function getModelApiEndpoint(modelName) {
    const model = allModels.find((m) => m.value === modelName);
    if (model) {
      return `/chat/${model.api_path}/${model.value}`;
    }
    return null; // Model not found
  }

  sendPromptForm.addEventListener("submit", async (e) => {
    e.preventDefault();
    sendPromptForm.classList.add("was-validated");
    const promptText = newPromptTextInput.value.trim();

    if (!promptText) {
      showMessageBox("Please type a message.", "danger");
      return;
    }

    const modelLeft = modelSelectLeft.value;
    const modelRight = modelSelectRight.value;
    if (!modelLeft || !modelRight) {
      showMessageBox("Please select a model for both chat boxes.", "danger");
      return;
    }

    setLoadingChat(true);

    try {
      let sessionToUseId = activeChatSessionId;
      let sessionToUseTitle = promptText.substring(0, 100);

      if (isNewSessionActive) {
        console.log(
          "DEBUG: sendPromptForm submit: New session active. Attempting to create session with title:",
          sessionToUseTitle
        );
        const createSessionResponse = await fetchAPI("/chat_sessions/", {
          method: "POST",
          body: JSON.stringify({
            title: sessionToUseTitle,
            user_id: currentUser.user_id,
          }),
        });

        if (!createSessionResponse || !createSessionResponse.ok) {
          const errorData = createSessionResponse
            ? await createSessionResponse.json()
            : {};
          console.error(
            "DEBUG: sendPromptForm submit: Failed to create new chat session. Status:",
            createSessionResponse.status,
            "Error Data:",
            errorData
          );
          showMessageBox(
            errorData.detail || "Failed to create new chat session.",
            "danger"
          );
          return;
        }
        const newSessionData = await createSessionResponse.json();
        sessionToUseId = newSessionData.session_id;
        sessionToUseTitle = newSessionData.title;

        activeChatSessionId = sessionToUseId;
        activeChatSessionTitle = sessionToUseTitle;
        isNewSessionActive = false;

        history.pushState(
          { id: sessionToUseId, title: sessionToUseTitle },
          "",
          `/dashboard?session=${sessionToUseId}&title=${encodeURIComponent(
            sessionToUseTitle
          )}`
        );
        await fetchChatSessionsForSidebar();
        console.log(
          "DEBUG: sendPromptForm submit: New chat session created:",
          newSessionData
        );
      }

      const userMessage = { role: "user", content: promptText };
      const userPromptsListChecked = getCheckedUserPrompts();
      console.log("DEBUG: Checked User Prompts:", userPromptsListChecked);
      chatHistoryLeft.push(userMessage);
      chatHistoryRight.push(userMessage);

      appendMessageToChatBox(chatHistoryLeftEl, "You", promptText, "user");
      appendMessageToChatBox(chatHistoryRightEl, "You", promptText, "user");

      const endpointLeft = getModelApiEndpoint(modelLeft);
      const endpointRight = getModelApiEndpoint(modelRight);

      const apiCallLeft = fetchLLMAPI(endpointLeft, {
        method: "POST",
        body: JSON.stringify({
          question: promptText,
          session_id: sessionToUseId,
          chat_history: chatHistoryLeft,
        }),
      });

      const apiCallRight = fetchLLMAPI(endpointRight, {
        method: "POST",
        body: JSON.stringify({
          question: promptText,
          session_id: sessionToUseId,
          chat_history: chatHistoryRight,
        }),
      });

      const [responsePromiseLeft, responsePromiseRight] =
        await Promise.allSettled([apiCallLeft, apiCallRight]);

      let answerLeft = "Error: No response from model.";
      let answerRight = "Error: No response from model.";

      if (
        responsePromiseLeft.status === "fulfilled" &&
        responsePromiseLeft.value &&
        responsePromiseLeft.value.ok
      ) {
        const data = await responsePromiseLeft.value.json();
        answerLeft = data.answer || "No answer provided.";
        chatHistoryLeft.push({ role: "assistant", content: answerLeft });
        appendMessageToChatBox(
          chatHistoryLeftEl,
          chatTitleLeft.textContent.replace(" Conversation", ""),
          answerLeft,
          "assistant"
        );
      } else {
        const errorReason = responsePromiseLeft.reason
          ? responsePromiseLeft.reason.message
          : "Unknown error";
        console.error(`Failed to get response from ${modelLeft}:`, errorReason);
        showMessageBox(`Failed to get response from ${modelLeft}.`, "danger");
        chatHistoryLeft.push({ role: "assistant", content: answerLeft });
        appendMessageToChatBox(
          chatHistoryLeftEl,
          chatTitleLeft.textContent.replace(" Conversation", ""),
          answerLeft,
          "assistant"
        );
      }

      if (
        responsePromiseRight.status === "fulfilled" &&
        responsePromiseRight.value &&
        responsePromiseRight.value.ok
      ) {
        const data = await responsePromiseRight.value.json();
        answerRight = data.answer || "No answer provided.";
        chatHistoryRight.push({ role: "assistant", content: answerRight });
        appendMessageToChatBox(
          chatHistoryRightEl,
          chatTitleRight.textContent.replace(" Conversation", ""),
          answerRight,
          "assistant"
        );
      } else {
        const errorReason = responsePromiseRight.reason
          ? responsePromiseRight.reason.message
          : "Unknown error";
        console.error(
          `Failed to get response from ${modelRight}:`,
          errorReason
        );
        showMessageBox(`Failed to get response from ${modelRight}.`, "danger");
        chatHistoryRight.push({ role: "assistant", content: answerRight });
        appendMessageToChatBox(
          chatHistoryRightEl,
          chatTitleRight.textContent.replace(" Conversation", ""),
          answerRight,
          "assistant"
        );
      }

      const savePromptResponse = await fetchAPI("/prompts", {
        method: "POST",
        body: JSON.stringify({
          session_id: sessionToUseId,
          user_id: currentUser.user_id,
          prompt_text: promptText,
          llm_responses: [answerLeft, answerRight],
        }),
      });

      if (savePromptResponse && savePromptResponse.ok) {
        newPromptTextInput.value = "";
        sendPromptForm.classList.remove("was-validated");
        await fetchCurrentUserProfile();
        console.log(
          "DEBUG: sendPromptForm submit: Prompt and LLM responses saved successfully."
        );
      } else {
        const errorData = savePromptResponse
          ? await savePromptResponse.json()
          : {};
        console.error(
          "DEBUG: sendPromptForm submit: Failed to save prompt/responses. Status:",
          savePromptResponse.status,
          "Error Data:",
          errorData
        );
        showMessageBox(
          errorData.detail || "Failed to save prompt and LLM responses.",
          "danger"
        );
      }
    } catch (error) {
      console.error(
        "DEBUG: sendPromptForm submit: Caught unexpected error:",
        error
      );
      showMessageBox("An unexpected error occurred.", "danger");
    } finally {
      setLoadingChat(false);
    }
  });

  function setLoadingChat(isLoading) {
    newPromptTextInput.disabled = isLoading;
    sendPromptButton.disabled = isLoading;
    if (isLoading) {
      sendPromptButton.innerHTML = `<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>`;
    } else {
      sendPromptButton.innerHTML = `<i class="bi bi-send-fill"></i>`;
    }
  }

  // --- Event Listeners for Global/Sidebar Actions ---

  newSessionButton.addEventListener("click", async () => {
    console.log("DEBUG: New Session Button Clicked.");
    initializeChatArea(null, null);
  });

  headerLogoutLink.addEventListener("click", (e) => {
    e.preventDefault();
    console.log("DEBUG: Header Logout clicked. Calling clearToken().");
    clearToken();
  });

  function showLoadingSpinner(element, show) {
    if (show) {
      element.classList.remove("d-none");
    } else {
      element.classList.add("d-none");
    }
  }

  function updateSidebarActiveSession() {
    document
      .querySelectorAll("#sessions-7-days a, #sessions-30-days a")
      .forEach((link) => {
        link.classList.remove("active");
        link.removeAttribute("aria-current");
      });

    if (activeChatSessionId) {
      const activeLink = document.querySelector(
        `[data-chat-session-id="${activeChatSessionId}"]`
      );
      if (activeLink) {
        activeLink.classList.add("active");
        activeLink.setAttribute("aria-current", "true");
      }
    }
  }

  function navigateToChatSession(sessionId, sessionTitle) {
    history.pushState(
      { id: sessionId, title: sessionTitle },
      "",
      `/dashboard?session=${sessionId}&title=${encodeURIComponent(
        sessionTitle
      )}`
    );
    initializeChatArea(sessionId, sessionTitle);
  }

  function updateChatTitles() {
    const selectedLeft =
      modelSelectLeft.options[modelSelectLeft.selectedIndex].text;
    const selectedRight =
      modelSelectRight.options[modelSelectRight.selectedIndex].text;
    chatTitleLeft.textContent = `${selectedLeft} Conversation`;
    chatTitleRight.textContent = `${selectedRight} Conversation`;
  }

  // Function to populate and sync model dropdowns
  function syncModelDropdowns() {
    const selectedLeft = modelSelectLeft.value;
    const selectedRight = modelSelectRight.value;

    // Clear and repopulate left dropdown
    modelSelectLeft.innerHTML = "";
    allModels.forEach((model) => {
      if (model.value !== selectedRight) {
        const option = document.createElement("option");
        option.value = model.value;
        option.textContent = model.text;
        modelSelectLeft.appendChild(option);
      }
    });
    modelSelectLeft.value = selectedLeft;

    // Clear and repopulate right dropdown
    modelSelectRight.innerHTML = "";
    allModels.forEach((model) => {
      if (model.value !== selectedLeft) {
        const option = document.createElement("option");
        option.value = model.value;
        option.textContent = model.text;
        modelSelectRight.appendChild(option);
      }
    });
    modelSelectRight.value = selectedRight;

    updateChatTitles();
  }

  // --- Initial Load Logic ---
  const LLM_API_BASE_URL = "{{ llm_api_base_url }}".replace(/\/+$/, "");

  async function populateModelDropdownsFromText() {
    try {
      const response = await fetch("/static/models.txt");
      if (!response.ok) {
        throw new Error("Failed to load models list from file.");
      }
      const data = await response.text();
      allModels = data
        .split("\n")
        .map((line) => {
          const parts = line.split(":");
          if (parts.length === 3) {
            const api_path = parts[0].trim();
            const value = parts[1].trim();
            const text = parts[2].trim();
            return { value, text, api_path };
          }
          return null;
        })
        .filter((model) => model !== null);

      // Initial population
      allModels.forEach((model) => {
        const optionLeft = document.createElement("option");
        optionLeft.value = model.value;
        optionLeft.textContent = model.text;
        modelSelectLeft.appendChild(optionLeft);

        const optionRight = document.createElement("option");
        optionRight.value = model.value;
        optionRight.textContent = model.text;
        modelSelectRight.appendChild(optionRight);
      });

      // Set initial default models and sync
      modelSelectLeft.value = "gpt-4o";
      modelSelectRight.value = "gemini-1.5-pro-latest";
      syncModelDropdowns();

      // Add event listeners for syncing
      modelSelectLeft.addEventListener("change", syncModelDropdowns);
      modelSelectRight.addEventListener("change", syncModelDropdowns);

      console.log("Model dropdowns populated and synced successfully.");
    } catch (error) {
      console.error("Error populating model dropdowns:", error);
    }
  }

  document.addEventListener("DOMContentLoaded", async () => {
    console.log("Dashboard using BACKEND_API_URL:", BACKEND_API_URL);
    console.log("Dashboard using LLM_API_BASE_URL:", LLM_API_BASE_URL);
    console.log("DEBUG: DOMContentLoaded: Page loaded.");

    await populateModelDropdownsFromText();

    authToken = localStorage.getItem("jwt_token");
    if (!authToken) {
      console.log(
        "DEBUG: DOMContentLoaded: No auth token found. Redirecting to /login."
      );
      window.location.href = "/login";
      return;
    } else {
      console.log(
        "DEBUG: DOMContentLoaded: Auth token found. Proceeding with dashboard initialization."
      );
    }

    await fetchCurrentUserProfile();
    await fetchAndDisplaySystemPrompts();

    if (currentUser && currentUser.user_id) {
      await fetchChatSessionsForSidebar();
      await fetchAndDisplayUserPrompts(currentUser.user_id);
    } else {
      console.error(
        "DEBUG: DOMContentLoaded: currentUser or user_id not available. Cannot fetch chat sessions."
      );
      noSessionsSidebar.classList.remove("d-none");
      noSessionsSidebar.textContent =
        "User profile not loaded. Cannot load sessions.";
    }

    const urlParams = new URLSearchParams(window.location.search);
    const initialChatSessionId = urlParams.get("session");
    const initialChatSessionTitle = urlParams.get("title");

    if (initialChatSessionId && initialChatSessionTitle) {
      console.log(
        "DEBUG: DOMContentLoaded: Found initial session in URL. ID:",
        initialChatSessionId,
        "Title:",
        initialChatSessionTitle
      );
      initializeChatArea(initialChatSessionId, initialChatSessionTitle);
    } else {
      console.log(
        "DEBUG: DOMContentLoaded: No initial session in URL. Initializing empty chat area."
      );
      initializeChatArea(null, null);
    }
  });

  window.addEventListener("popstate", (event) => {
    console.log("DEBUG: Popstate event triggered.");
    const urlParams = new URLSearchParams(window.location.search);
    const popstateChatSessionId = urlParams.get("session");
    const popstateChatSessionTitle = urlParams.get("title");

    if (popstateChatSessionId && popstateChatSessionTitle) {
      console.log(
        "DEBUG: Popstate: Found session in URL. ID:",
        popstateChatSessionId,
        "Title:",
        popstateChatSessionTitle
      );
      initializeChatArea(popstateChatSessionId, popstateChatSessionTitle);
    } else {
      console.log(
        "DEBUG: Popstate: No session in URL. Initializing empty chat area."
      );
      initializeChatArea(null, null);
    }
  });

  function showLoadingSpinner(element, show) {
    if (show) {
      element.classList.remove("d-none");
    } else {
      element.classList.add("d-none");
    }
  }

  function toggleSidebar(side) {
    const sidebar = document.getElementById(
      side === "left" ? "left-sidebar" : "right-sidebar"
    );
    sidebar.classList.toggle("collapsed");
  }

  const leftSidebar = document.getElementById("left-sidebar");
  const rightSidebar = document.getElementById("right-sidebar");

  leftSidebar.addEventListener("mouseenter", () => {
    if (leftSidebar.classList.contains("collapsed")) {
      leftSidebar.classList.remove("collapsed");
    }
  });

  leftSidebar.addEventListener("mouseleave", () => {
    if (!leftSidebar.classList.contains("collapsed")) {
      leftSidebar.classList.add("collapsed");
    }
  });

  rightSidebar.addEventListener("mouseenter", () => {
    if (rightSidebar.classList.contains("collapsed")) {
      rightSidebar.classList.remove("collapsed");
    }
  });

  rightSidebar.addEventListener("mouseleave", () => {
    if (!rightSidebar.classList.contains("collapsed")) {
      rightSidebar.classList.add("collapsed");
    }
  });

  function toggleFullScreen() {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().catch((err) => {
        console.error("Fullscreen request failed:", err);
      });
    } else {
      document.exitFullscreen();
    }
  }

  document
    .getElementById("fullscreen-toggle")
    .addEventListener("click", toggleFullScreen);

  document.addEventListener("fullscreenchange", () => {
    const fsButton = document.getElementById("fullscreen-toggle");
    if (fsButton) {
      fsButton.classList.toggle(
        "bi-arrows-fullscreen",
        !document.fullscreenElement
      );
      fsButton.classList.toggle("bi-dash-square", !!document.fullscreenElement);
    }

    const isFullscreen = !!document.fullscreenElement;
    const leftSidebar = document.getElementById("left-sidebar");
    const rightSidebar = document.getElementById("right-sidebar");

    if (isFullscreen) {
      if (!leftSidebar.classList.contains("collapsed")) {
        leftSidebar.classList.add("collapsed");
      }
      if (!rightSidebar.classList.contains("collapsed")) {
        rightSidebar.classList.add("collapsed");
      }
    }
  });

  // Optional: F11 shortcut
  document.addEventListener("keydown", (e) => {
    if (e.key === "F11") {
      e.preventDefault();
      toggleFullScreen();
    }
  });
</script>
{% endblock %}
