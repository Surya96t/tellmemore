---
applyTo: "**/*.ts,**/*.tsx,**/*.js,**/*.jsx"
---

# Frontend-Next Coding Instructions

## TypeScript Rules (STRICT ENFORCEMENT)

### Rule 1: NO `any` Type

- **NEVER** use `any` type in the codebase
- Use proper type definitions or `unknown` if type is truly unknown
- For third-party libraries without types, create `.d.ts` declaration files
- Use TypeScript's strict mode

```typescript
// ❌ NEVER DO THIS
function getData(data: any) {}
const result: any = fetchData();

// ✅ DO THIS INSTEAD
function getData(data: UserData | SessionData) {}
const result: UserData = fetchData();

// ✅ OR IF TRULY UNKNOWN
function getData(data: unknown) {
  if (isUserData(data)) {
    // Type guard narrows to UserData
    return data.userId;
  }
}
```

### Rule 2: Explicit Return Types

- All functions must have explicit return type annotations
- Include async functions (`Promise<Type>`)

```typescript
// ❌ NEVER DO THIS
async function fetchSessions() {
  return backendDa.getSessions();
}

// ✅ DO THIS INSTEAD
async function fetchSessions(): Promise<ChatSession[]> {
  return backendDa.getSessions();
}
```

### Rule 3: Type Imports

- Use `import type` for type-only imports
- Helps with tree-shaking and build optimization

```typescript
// ✅ DO THIS
import type { ChatSession, UserPrompt } from "@/types/chat";
import { backendDa } from "@/lib/api/backend-da";
```

---

## Next.js 16 Specific Rules

### Rule 4: Async Request APIs (BREAKING CHANGE)

- **ALL** pages and layouts must await `params` and `searchParams`
- This is a Next.js 16 requirement

```typescript
// ❌ NEVER DO THIS (Next.js 15 pattern)
export default function Page({ params, searchParams }) {
  const { id } = params;
}

// ✅ DO THIS INSTEAD (Next.js 16 required)
export default async function Page({
  params,
  searchParams,
}: {
  params: Promise<{ id: string }>;
  searchParams: Promise<{ query?: string }>;
}) {
  const { id } = await params;
  const { query } = await searchParams;
}
```

### Rule 5: Server Components vs Client Components

- Use Server Components by default
- Only add `'use client'` when absolutely necessary:
  - Interactivity (onClick, onChange, etc.)
  - Browser APIs (localStorage, window, etc.)
  - React hooks (useState, useEffect, etc.)
  - Event listeners

```typescript
// ✅ Server Component (default, no directive needed)
export default async function SessionsList() {
  const sessions = await fetchSessions(); // Can fetch directly
  return <SessionGrid sessions={sessions} />;
}

// ✅ Client Component (when needed)
("use client");
export function ChatInput() {
  const [input, setInput] = useState(""); // Needs client for hooks
  return <textarea value={input} onChange={(e) => setInput(e.target.value)} />;
}
```

### Rule 6: Cache Components Usage

- Use `"use cache"` for static/slowly-changing Server Components
- Use `"use cache: private"` for user-specific cached data
- Always wrap cached components in `<Suspense>`

```typescript
// ✅ Public cache for static data
"use cache";
export async function SystemPromptsSection() {
  const prompts = await fetchSystemPrompts();
  return <PromptsList prompts={prompts} />;
}

export const cacheLife = {
  hours: 1,
  tags: ["system-prompts"],
};

// ✅ Private cache for user data
("use cache: private");
export async function UserQuotaWidget({ userId }: { userId: string }) {
  const quota = await fetchUserQuota(userId);
  return <QuotaDisplay quota={quota} />;
}

// ✅ Usage with Suspense
<Suspense fallback={<PromptsSkeleton />}>
  <SystemPromptsSection />
</Suspense>;
```

### Rule 7: Server Actions

- Use Server Actions for ALL mutations
- Always include `'use server'` directive
- Return type-safe results, not throwing errors for UX errors

```typescript
// ✅ Server Action pattern
"use server";

import { revalidatePath } from "next/cache";

export async function createSession(
  formData: FormData
): Promise<
  { success: true; session: ChatSession } | { success: false; error: string }
> {
  const title = formData.get("title") as string;

  if (!title || title.length < 3) {
    return { success: false, error: "Title must be at least 3 characters" };
  }

  const session = await backendDa.createSession(title);
  revalidatePath("/dashboard/sessions");

  return { success: true, session };
}
```

---

## State Management Rules

### Rule 8: React Query for Backend Data ONLY

- Use React Query ONLY for server data (sessions, prompts, quota, chat history)
- DO NOT use React Query for UI preferences or form state

```typescript
// ✅ React Query for server data
export function useSessions() {
  return useQuery({
    queryKey: ["sessions"],
    queryFn: (): Promise<ChatSession[]> => backendDa.getSessions(),
    staleTime: 60_000,
  });
}

// ❌ NEVER use React Query for UI state
// Don't do: useQuery({ queryKey: ['theme'], ... })
```

### Rule 9: Zustand for UI Preferences ONLY

- Use Zustand ONLY for client-side UI preferences
- Always use `persist` middleware for localStorage sync
- DO NOT use Zustand for backend data

```typescript
// ✅ Zustand for UI preferences
export const useUiStore = create<UiState>()(
  persist(
    (set) => ({
      theme: "dark",
      sidebarCollapsed: false,
      toggleTheme: () =>
        set((state) => ({
          theme: state.theme === "dark" ? "light" : "dark",
        })),
    }),
    { name: "tellmemore-ui-preferences" }
  )
);

// ❌ NEVER use Zustand for backend data
// Don't do: sessions: [], setSessions: ...
```

### Rule 10: Local useState for Ephemeral State

- Use `useState` for form inputs, modals, temporary UI state
- Do NOT persist with React Query or Zustand

```typescript
// ✅ Local state for forms
const [chatInput, setChatInput] = useState("");
const [isModalOpen, setIsModalOpen] = useState(false);
```

---

## API & BFF Layer Rules

### Rule 11: NO Direct Backend Calls from Client

- ALL API calls must go through BFF layer (`/api/*` routes)
- NEVER fetch backend URLs directly from client components
- Backend URLs are server-side environment variables only

```typescript
// ❌ NEVER DO THIS
const response = await fetch(
  "https://backend-da-301474384730.us-east4.run.app/api/v1/sessions"
);

// ✅ DO THIS INSTEAD (through BFF)
const response = await fetch("/api/backend-da/sessions");

// ✅ OR USE TYPE-SAFE CLIENT
import { backendDa } from "@/lib/api/backend-da";
const sessions = await backendDa.getSessions();
```

### Rule 12: Type-Safe API Clients

- Use centralized API client classes
- All methods must have return types
- Handle errors gracefully

```typescript
// ✅ Type-safe API client
export class BackendDaClient {
  private baseUrl = "/api/backend-da";

  async getSessions(): Promise<ChatSession[]> {
    const response = await fetch(`${this.baseUrl}/sessions`);
    if (!response.ok) {
      throw new Error(`Failed to fetch sessions: ${response.statusText}`);
    }
    return response.json();
  }
}

export const backendDa = new BackendDaClient();
```

---

## Component & File Organization Rules

### Rule 13: File Naming Conventions

- Components: PascalCase (`ChatMessage.tsx`)
- Utilities/hooks: camelCase (`useChat.ts`, `formatDate.ts`)
- Server Actions: camelCase files, named exports (`actions/sessions.ts`)
- API routes: lowercase (`route.ts` in folders)

### Rule 14: Component Structure

- One component per file
- Export component as default (unless multiple related components)
- Place types in same file or shared `types/` folder

```typescript
// ✅ ChatMessage.tsx
import type { Message } from "@/types/chat";

interface ChatMessageProps {
  message: Message;
  onRetry?: () => void;
}

export default function ChatMessage({ message, onRetry }: ChatMessageProps) {
  // Component logic
}
```

### Rule 15: Import Order

- Group imports in this order:
  1. React/Next.js
  2. External libraries
  3. Internal components/utils
  4. Types
  5. Styles

```typescript
// ✅ Proper import order
import { Suspense } from "react";
import { redirect } from "next/navigation";

import { useQuery } from "@tanstack/react-query";
import { create } from "zustand";

import { ChatMessage } from "@/components/chat/ChatMessage";
import { backendDa } from "@/lib/api/backend-da";

import type { ChatSession, Message } from "@/types/chat";

import "@/app/globals.css";
```

---

## Error Handling Rules

### Rule 16: Graceful Error Handling

- Use error boundaries for component errors
- Return error states from Server Actions, don't throw
- Show user-friendly error messages

```typescript
// ✅ Server Action error handling
"use server";
export async function createSession(title: string) {
  try {
    const session = await backendDa.createSession(title);
    return { success: true, session };
  } catch (error) {
    console.error("Failed to create session:", error);
    return {
      success: false,
      error: "Failed to create session. Please try again.",
    };
  }
}

// ✅ Error boundary
// app/(dashboard)/error.tsx
("use client");
export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  return (
    <div className='error-container'>
      <h2>Something went wrong!</h2>
      <p>{error.message}</p>
      <button onClick={reset}>Try again</button>
    </div>
  );
}
```

---

## Performance Rules

### Rule 17: Image Optimization

- Always use Next.js `<Image>` component
- Specify width and height
- Use appropriate sizes prop

```typescript
// ✅ Optimized images
import Image from "next/image";

<Image
  src='/logo.png'
  alt='TellMeMore Logo'
  width={200}
  height={50}
  priority // For above-fold images
/>;
```

### Rule 18: Dynamic Imports for Large Components

- Use dynamic imports for large client components
- Disable SSR for browser-only components

```typescript
// ✅ Dynamic import
import dynamic from "next/dynamic";

const CodeEditor = dynamic(() => import("@/components/CodeEditor"), {
  ssr: false,
  loading: () => <EditorSkeleton />,
});
```

---

## Testing Rules

### Rule 19: Test Coverage Requirements

- All Server Actions must have tests
- All API routes must have integration tests
- Critical user flows must have E2E tests

### Rule 20: Type-Safe Tests

- Use TypeScript for all tests
- No `any` in test files either
- Mock with proper types

```typescript
// ✅ Type-safe test
import { render, screen } from "@testing-library/react";
import type { ChatSession } from "@/types/chat";
import SessionsList from "./SessionsList";

const mockSession: ChatSession = {
  session_id: "123",
  title: "Test Session",
  created_at: new Date(),
  updated_at: new Date(),
};

test("renders session title", () => {
  render(<SessionsList sessions={[mockSession]} />);
  expect(screen.getByText("Test Session")).toBeInTheDocument();
});
```

---

## Migration Reference

For detailed migration guidance, see:

- [frontend-next-migration-plan.md](../frontend-next-migration-plan.md) - Implementation roadmap
- [nextjs-16-migration-rationale.md](../nextjs-16-migration-rationale.md) - Technical decisions
- [MIGRATION-SUMMARY.md](../MIGRATION-SUMMARY.md) - Quick reference

---

## Summary: Key Rules to Remember

1. ❌ **NEVER** use `any` type
2. ✅ Always await `params` and `searchParams` in Next.js 16
3. ✅ Use React Query for backend data, Zustand for UI preferences
4. ✅ Use Server Actions for mutations
5. ✅ All API calls through BFF layer (no direct backend access)
6. ✅ Explicit return types on all functions
7. ✅ Server Components by default, Client Components only when needed
8. ✅ Use `"use cache"` for static Server Components
9. ✅ Proper error handling (don't throw from Server Actions)
10. ✅ Next.js `<Image>` for all images

**When in doubt, check the migration docs!**
